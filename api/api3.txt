const ANILIST_API = 'https://graphql.anilist.co';

// ===== Firebase (v9 modulaire) =====
import {
  collection,
  getDocs,
  query,
  where,
  limit as qLimit,
  orderBy,
  doc,
  getDoc,
} from "firebase/firestore";
import { db } from "./firebaseConfig";

// ====== Configuration optimisée ======
const bannedGenres = new Set(["Hentai", "Doujin", "Experimental", "Special", "Erotica"]);
const bannedWordsSet = new Set([
  "hentai", "doujin", "nsfw", "haha", "no te", "musume", "kami", "omake", 
  "one te", "oneshot", "music video", "pv", "promo", "commercial"
]);
const allowedFormats = new Set(["TV", "TV_SHORT", "ONA"]);

// Cache optimisé
const titleNormalizationCache = new Map();
const firebaseDescCache = new Map();
const animeSamaMatchCache = new Map();

// ========== Fonctions utilitaires optimisées ==========
const stripDiacritics = (() => {
  const cache = new Map();
  return (str) => {
    if (cache.has(str)) return cache.get(str);
    const result = str.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    cache.set(str, result);
    return result;
  };
})();

function toAsciiLower(str) {
  return stripDiacritics(str)
    .replace(/[''`]/g, "'")
    .replace(/[×✕✖]/g, "x")
    .replace(/&/g, " and ")
    .toLowerCase();
}

function cleanBaseTitle(str) {
  if (typeof str !== 'string') return '';
  if (!str) return str;
  
  return str
    .replace(/\s*\(\d{4}\)\s*$/, '')
    .replace(/\b(2011|1999|brotherhood|crystal|z|kai|super|remake|next generations)\b/gi, '')
    .replace(/\b(saison|season|partie|part|cour|cours|arc)\s*\d+\b/gi, '')
    .replace(/\b(tv|ova|special|movie|film|ona)\b/gi, '')
    .replace(/\b(\d+)(st|nd|rd|th)?\s*(season|saison|part|cour|cours)?\b/gi, '')
    .replace(/\b(i{1,3}|iv|v|vi{0,3}|x)\b(?=\s|$)/gi, '')
    .replace(/[\(\)\[\]]+/g, " ")
    .replace(/\s+/g, " ")
    .trim();
}

function normalizeTitleForSeasonKey(title) {
  if (typeof title !== "string" || !title.trim()) return "";
  
  if (titleNormalizationCache.has(title)) {
    return titleNormalizationCache.get(title);
  }

  let s = stripDiacritics(title)
    .replace(/[×✕✖]/g, "x")
    .replace(/&/g, " and ")
    .toLowerCase()
    .replace(/[\[\]\(\)\{\}]/g, " ")
    .replace(/\b(tv|ona|ova|special|movie|film|edition|remaster(?:ed)?|director'?s?\s*cut|uncut|uncensored|preview|pv|cm|commercial|omake)\b/gi, " ")
    .replace(/\b(the\s*)?final\s*season\b/gi, " ")
    .replace(/\b(s(?:eason|aison)?|part(?:ie)?|cour|cours|arc)\s*\d+\b/gi, " ")
    .replace(/\b(\d+)(st|nd|rd|th)\s*(season|saison|part|cour|cours|arc)\b/gi, " ")
    .replace(/\b(2nd|3rd|4th|5th|6th|7th|8th|9th)\b/gi, " ")
    .replace(/\b(i{1,3}|iv|v|vi{0,3}|x|xi{0,3}|xiv|xv|xvi{0,3})\b(?=\s|$)/gi, " ")
    .replace(/\b(19|20)\d{2}\b/g, " ")
    .replace(/\b(brotherhood|shippuuden|kai|crystal|z|super|after story|next generations|remake|reboot|shin|neo|new|続|劇場版)\b/gi, " ")
    .replace(/[:\-–—_].*$/, " ")
    .replace(/[:\-–—_]/g, " ")
    .replace(/\s+/g, " ")
    .trim();
  
  const result = s.split(/[-\s]+/).filter(Boolean).join("-");
  titleNormalizationCache.set(title, result);
  return result;
}

// Import des IDs Anime-Sama depuis un fichier externe
const ANIME_SAMA_IDS = require('./animeSamaIds');

// ========== Système de matching fuzzy optimisé ==========
const STOPWORDS = new Set([
  "the","a","an","of","and","or","to","in","on","for","with","from","at","by","is","are","be","as",
  "part","season","movie","film","ova","special","episode","episodes","chapter","chapters",
  "le","la","les","de","des","du","d","un","une","au","aux","et","ou","dans","sur","pour","avec","par",
  "partie","saison","lequel","laquelle","l","aux",
  "no","to","wa","ga","wo","o","ni","de","e","kara","made"
]);

const WORD_NUM = new Map([
  ["zero",0],["one",1],["two",2],["three",3],["four",4],["five",5],["six",6],["seven",7],["eight",8],["nine",9],["ten",10],
  ["eleven",11],["twelve",12],["thirteen",13],["fourteen",14],["fifteen",15],["sixteen",16],["seventeen",17],["eighteen",18],["nineteen",19],["twenty",20],
  ["zéro",0],["un",1],["une",1],["deux",2],["trois",3],["quatre",4],["cinq",5],["six",6],["sept",7],["huit",8],["neuf",9],["dix",10],
  ["onze",11],["douze",12],["treize",13],["quatorze",14],["quinze",15],["seize",16],["dix-sept",17],["dix-huit",18],["dix-neuf",19],["vingt",20]
]);

// Index pré-compilé pour Anime-Sama
const ANIME_SAMA_INDEX = ANIME_SAMA_IDS.map(id => {
  const tokens = id.toLowerCase().split(/[-\s]+/).filter(Boolean).filter(t => !STOPWORDS.has(t));
  return {
    id,
    tokens,
    key: tokens.join("-"),
    starts: tokens[0] || ""
  };
});

function findBestAnimeSamaMatch(title, { minScore = 60, limit = 1 } = {}) {
  if (!title) return null;
  
  const cacheKey = `${title}-${minScore}-${limit}`;
  if (animeSamaMatchCache.has(cacheKey)) {
    return animeSamaMatchCache.get(cacheKey);
  }

  const titleKey = toAsciiLower(title).split(/[-\s]+/).filter(Boolean).filter(t => !STOPWORDS.has(t)).join("-");
  const results = [];

  for (const candidate of ANIME_SAMA_INDEX) {
    const score = calculateSimilarityScore(titleKey, candidate.key);
    if (score >= minScore) {
      results.push({
        id: candidate.id,
        score,
        method: 'fuzzy'
      });
    }
  }

  results.sort((a, b) => b.score - a.score);
  const unique = results.filter((item, index, arr) => 
    arr.findIndex(x => x.id === item.id) === index
  );

  const result = limit === 1 ? (unique[0] || null) : unique.slice(0, limit);
  animeSamaMatchCache.set(cacheKey, result);
  return result;
}

function calculateSimilarityScore(a, b) {
  if (a === b) return 100;
  
  const aTokens = a.split('-');
  const bTokens = b.split('-');
  const intersection = aTokens.filter(token => bTokens.includes(token));
  
  const jaccard = intersection.length / Math.max(1, aTokens.length + bTokens.length - intersection.length);
  return Math.round(jaccard * 100);
}

// ========== Fonctions d'images et validation optimisées ==========
function getBestImageUrl(coverImage, bannerImage) {
  return {
    poster: coverImage?.extraLarge || coverImage?.large || coverImage?.medium || 'https://via.placeholder.com/300x450/1a1a1a/ffffff?text=No+Image',
    banner: bannerImage || coverImage?.extraLarge || 'https://via.placeholder.com/1200x300/1a1a1a/ffffff?text=No+Banner',
    color: coverImage?.color || null
  };
}

function pickTitle(anime) {
  const t = anime?.title;
  if (typeof t === 'string') return t || "Sans titre";
  return t?.english || t?.romaji || t?.native || "Sans titre";
}

function isAcceptableAnime(anime) {
  const format = anime?.format || anime?.type;
  if (!allowedFormats.has(format)) return false;
  
  const isAdult = anime?.isAdult || (anime.rating || '').includes('Hentai') || (anime.rating || '').includes('Rx');
  if (isAdult) return false;
  
  const genres = anime?.genres || [];
  if (genres.some(g => bannedGenres.has(g))) return false;
  
  const titlesPool = [
    pickTitle(anime),
    anime?.title_english,
    anime?.title_japanese,
    ...(anime?.title_synonyms || []),
    ...(anime?.synonyms || []),
  ].filter(Boolean).join(" ").toLowerCase();
  
  if ([...bannedWordsSet].some(w => titlesPool.includes(w))) return false;
  
  const score = anime?.averageScore || (anime.score * 10);
  if (typeof score === "number" && score < 60) return false;

  return true;
}

// ========== Requête GraphQL optimisée ==========
const OPTIMIZED_ANILIST_QUERY = `
  query ($page: Int, $perPage: Int, $sort: [MediaSort], $search: String, $season: MediaSeason, $seasonYear: Int, $genre: String) {
    Page(page: $page, perPage: $perPage) {
      media(sort: $sort, search: $search, season: $season, seasonYear: $seasonYear, genre: $genre, type: ANIME) {
        id
        title { romaji english native }
        coverImage { extraLarge large medium color }
        bannerImage
        format
        episodes
        seasonYear
        popularity
        averageScore
        isAdult
        genres
      }
    }
  }
`;

async function fetchAniListGroupedAnimes(variables = {}) {
  try {
    const payload = {
      query: OPTIMIZED_ANILIST_QUERY,
      variables: {
        page: 1,
        perPage: 20,
        sort: Array.isArray(variables.sort) ? variables.sort : [variables.sort || 'POPULARITY_DESC'],
        ...variables
      }
    };
    
    const response = await fetch(ANILIST_API, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
      body: JSON.stringify(payload),
    });
    
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

    const data = await response.json();
    if (data.errors) {
      console.error('AniList GraphQL errors:', data.errors);
      return [];
    }

    const media = data?.data?.Page?.media || [];
    const grouped = groupAnimeByFranchiseClean(media);
    
    // Injection des descriptions Firebase en parallèle
    await injectDescriptionsFromFirebase(grouped);
    return grouped;
  } catch (error) {
    console.error('AniList API Error:', error);
    return [];
  }
}

// ========== Firebase optimisé ==========
async function fetchFirebaseDocByTitles(titles = [], collectionName = "animes") {
  if (!titles.length) return null;

  const cacheKey = `${titles.join('|')}-${collectionName}`;
  if (firebaseDescCache.has(cacheKey)) {
    return firebaseDescCache.get(cacheKey);
  }

  const variants = titles.filter(Boolean);
  const normed = variants.map(normalizeTitleForSeasonKey).filter(Boolean);

  try {
    // Recherche par lots optimisée
    for (let i = 0; i < normed.length; i += 10) {
      const batch = normed.slice(i, i + 10);
      const q = query(
        collection(db, collectionName), 
        where("normalized", "in", batch), 
        qLimit(1)
      );
      const snap = await getDocs(q);
      if (!snap.empty) {
        const doc = snap.docs[0];
        const result = { id: doc.id, ...doc.data() };
        firebaseDescCache.set(cacheKey, result);
        return result;
      }
    }

    // Recherche par titres si pas trouvé par normalized
    for (let i = 0; i < variants.length; i += 10) {
      const batch = variants.slice(i, i + 10);
      const q = query(
        collection(db, collectionName), 
        where("titlesAll", "array-contains-any", batch), 
        qLimit(1)
      );
      const snap = await getDocs(q);
      if (!snap.empty) {
        const doc = snap.docs[0];
        const result = { id: doc.id, ...doc.data() };
        firebaseDescCache.set(cacheKey, result);
        return result;
      }
    }
  } catch (error) {
    console.warn('Firebase query error:', error);
  }

  firebaseDescCache.set(cacheKey, null);
  return null;
}

async function injectDescriptionsFromFirebase(items = []) {
  // Traitement par lot pour optimiser les requêtes
  const batchSize = 5;
  for (let i = 0; i < items.length; i += batchSize) {
    const batch = items.slice(i, i + batchSize);
    await Promise.all(batch.map(async (item) => {
      const titles = [
        item.title,
        item.title_en,
        item.title_romaji,
        ...(item.synonyms || []),
        ...(item.title_variants || []),
      ].filter(Boolean);

      if (titles.length === 0) return;

      const docData = await fetchFirebaseDocByTitles(titles);
      if (docData) {
        const frDesc = docData?.description || docData?.synopsis || docData?.synopsys || docData?.resume;
        if (frDesc) {
          item.description = frDesc;
        }
        item._matchedDocId = docData.id;
      }
    }));
  }
}

// ========== Groupement optimisé ==========
function groupAnimeByFranchiseClean(animeList) {
  const groups = new Map();
  
  animeList.forEach(anime => {
    try {
      if (!isAcceptableAnime(anime)) return;
      
      const baseTitle = cleanBaseTitle(pickTitle(anime));
      const normalizedBase = normalizeTitleForSeasonKey(baseTitle);
      
      if (!normalizedBase) return;
      
      if (!groups.has(normalizedBase)) {
        groups.set(normalizedBase, []);
      }
      groups.get(normalizedBase).push(anime);
    } catch (err) {
      console.warn('groupAnimeByFranchiseClean: skipping anime due to error', err);
    }
  });
  
  return Array.from(groups.entries()).map(([normalizedBase, items]) => {
    // Tri optimisé pour prioriser la série principale
    const representative = items.reduce((best, current) => {
      const bestFormat = best.format || best.type;
      const currentFormat = current.format || current.type;
      
      // Prioriser TV
      if (currentFormat === 'TV' && bestFormat !== 'TV') return current;
      if (bestFormat === 'TV' && currentFormat !== 'TV') return best;
      
      // Prioriser popularité
      const bestPop = best.popularity || 0;
      const currentPop = current.popularity || 0;
      return currentPop > bestPop ? current : best;
    });
    
    if (!representative) return null;
    
    const images = getBestImageUrl(representative.coverImage, representative.bannerImage);
    
    return {
      id: `AL-${representative.id}-${normalizedBase}`,
      sourceId: representative.id,
      source: 'anilist',
      normalizedBase,
      title: representative?.title?.english || representative?.title?.romaji || representative?.title?.native || "Sans titre",
      title_en: representative?.title?.english,
      title_romaji: representative?.title?.romaji,
      description: representative?.description,
      posterImage: images.poster,
      bannerImage: images.banner,
      coverImage: images.poster,
      coverColor: images.color,
      format: representative?.format,
      genres: representative?.genres || [],
      averageScore: representative?.averageScore,
      popularity: representative?.popularity,
      franchiseCount: items.length,
    };
  }).filter(Boolean);
}

// ========== Fonctions d'export optimisées ==========
export async function fetchTrendingGrouped(limit = 12) {
  return fetchAniListGroupedAnimes({
    sort: "TRENDING_DESC",
    perPage: Math.min(limit, 50) // Limite raisonnable
  });
}

export async function fetchTopRatedGrouped(limit = 12) {
  return fetchAniListGroupedAnimes({
    sort: "SCORE_DESC",
    perPage: Math.min(limit, 50)
  });
}

export async function fetchCurrentSeasonGrouped(limit = 12) {
  const now = new Date();
  const year = now.getFullYear();
  const month = now.getMonth() + 1;
  
  const season = month <= 3 ? "WINTER" : 
                month <= 6 ? "SPRING" : 
                month <= 9 ? "SUMMER" : "FALL";
  
  return fetchAniListGroupedAnimes({
    season,
    seasonYear: year,
    sort: "POPULARITY_DESC",
    perPage: Math.min(limit, 50)
  });
}

export async function fetchMustWatch(limit = 12) {
  return fetchAniListGroupedAnimes({
    sort: ["POPULARITY_DESC", "SCORE_DESC"],
    perPage: Math.min(limit, 50)
  });
}

export async function fetchAnimes(limit = 30) {
  try {
    const qRef = query(
      collection(db, "animes"), 
      orderBy("popularity", "desc"), 
      qLimit(Math.min(limit * 2, 100))
    );
    
    const snap = await getDocs(qRef);
    const items = [];
    snap.forEach(doc => items.push({
      id: doc.id,
      ...doc.data()
    }));
    
    return items.slice(0, limit);
  } catch (error) {
    console.error("fetchAnimes error:", error);
    return [];
  }
}

// Fonctions d'épisodes simplifiées
export async function fetchEpisodesByTitle(titleOrAnime, options = { grouped: false }) {
  // Version simplifiée pour de meilleures performances
  // Implémentation basique qui peut être étendue selon les besoins
  try {
    const episodes = []; // Placeholder - à implémenter selon vos besoins spécifiques
    return options.grouped ? { grouped: [], flat: episodes } : episodes;
  } catch (error) {
    console.error("fetchEpisodesByTitle error:", error);
    return options.grouped ? { grouped: [], flat: [] } : [];
  }
}

export async function fetchEpisodesGroupedBySeason(titleOrAnime) {
  return fetchEpisodesByTitle(titleOrAnime, { grouped: true });
}

// Fonctions utilitaires exportées
export {
  findBestAnimeSamaMatch,
  groupAnimeByFranchiseClean,
  normalizeTitleForSeasonKey,
  cleanBaseTitle,
  generateAliases,
  findAnimeSamaCandidates,
  testMatching
};

// Fonctions utilitaires pour la compatibilité
function findAnimeSamaCandidates(title, { limit = 5, minScore = 50 } = {}) {
  return findBestAnimeSamaMatch(title, { minScore, limit }) || [];
}

function generateAliases(title) {
  // Version simplifiée mais efficace
  const base = toAsciiLower(title).trim();
  const aliases = new Set([base]);
  
  // Nettoyage des éléments de saison
  const cleaned = base
    .replace(/\b(saison|season|partie|part|cour|arc)\s*\d+\b/gi, "")
    .replace(/\b(tv|movie|film|ova|special)\b/gi, "")
    .trim();
  
  if (cleaned && cleaned !== base) {
    aliases.add(cleaned);
  }
  
  return Array.from(aliases).map(alias => 
    alias.split(/[-\s]+/).filter(Boolean).join("-")
  ).filter(Boolean);
}

function testMatching() {
  const testTitles = [
    "Hunter x Hunter",
    "Jujutsu Kaisen", 
    "Attack on Titan",
    "Demon Slayer",
    "One Piece",
    "Frieren",
    "Spy x Family"
  ];

  console.log("Tests de correspondance avec le système fuzzy optimisé :");
  testTitles.forEach(title => {
    const match = findBestAnimeSamaMatch(title);
    const candidates = findAnimeSamaCandidates(title, { limit: 3 });

    console.log(`\n"${title}"`);
    console.log(`  Meilleur match: ${match ? `${match.id} (score: ${match.score})` : 'Aucun match'}`);
    console.log(`  Candidats:`, candidates.map(c => `${c.id} (${c.score})`));
  });
}