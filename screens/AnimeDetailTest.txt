// AnimeDetailsScreen V2.4 - Recherche améliorée pour films et franchises avec résolution canonique
import React, { useState, useEffect, useCallback, useRef, useMemo } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  Image,
  ActivityIndicator,
  Dimensions,
  FlatList,
  Alert,
  Animated,
  Platform,
  StatusBar,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { BlurView } from 'expo-blur';
import Ionicons from '@expo/vector-icons/Ionicons';
import MaterialIcons from '@expo/vector-icons/MaterialIcons';
import { useNavigation, useRoute } from '@react-navigation/native';
// MODIFICATION: Import de la nouvelle fonction
import { fetchEpisodesByTitle, fetchFranchiseDetails } from '../api/api';
import { doc, getDoc, collection, getDocs, query, where } from 'firebase/firestore';
import { db } from '../api/firebaseConfig';
import { VideoExtractorV5 } from '../api/VideoExtractorV5';

const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');
// CONFIGURATION SERVEUR RENDER
const RENDER_SERVER_URL = 'https://video-extractorv2py.onrender.com';
const COLORS = {
  primary: '#FF6B1A',
  secondary: '#F47521',
  background: '#0B0B0B',
  surface: '#141414',
  card: '#1A1A1A',
  text: '#FFFFFF',
  textSecondary: '#B3B3B3',
  textMuted: '#808080',
  border: '#2A2A2A',
  success: '#4CAF50',
  error: '#F44336',
  premium: '#FFD700',
  new: '#00BCD4',
};

// MAPPING DES TITRES CANONIQUES (inchangé)
const canonicalTitleMap = {
  // Anime japonais populaires
  'Naruto Shippuden': 'Naruto Shippuden',
  'Naruto Shippuuden': 'Naruto Shippuden',
  'Boruto: Naruto Next Generations': 'Boruto',
  'Boruto: Naruto the Movie': 'Boruto',
  'The Last: Naruto the Movie': 'Naruto',
  'Rascal Doesnt Not Dream of Santa Claus': 'Rascal Does Not Dream of Bunny Senpai',
  'Rascal Does Not Dream of a Sister Venturing Out': 'Rascal Does Not Dream of Bunny Senpai',
  'Rascal Does Not Dream of a Dreaming Girl': 'Rascal Does Not Dream of Bunny Senpai',
  'Seishun Buta Yarou': 'Rascal Does Not Dream of Bunny Senpai',
  'Seishun Buta Yaro': 'Rascal Does Not Dream of Bunny Senpai',
  'Seishun Buta Yarou wa Bunny Girl Senpai no Yume wo Minai': 'Rascal Does Not Dream of Bunny Senpai',
  'Kimetsu no Yaiba': 'Demon Slayer',
  'Kimetsu no Yaiba: Yuukaku-hen': 'Demon Slayer',
  'Kimetsu no Yaiba: Mugen Train': 'Demon Slayer',
  'Attack on Titan': 'Shingeki no Kyojin',
  'Shingeki no Kyojin': 'Attack on Titan',
  'Attack on Titan Season 1': 'Attack on Titan',
  'Attack on Titan Season 2': 'Attack on Titan',
  'Attack on Titan Season 3': 'Attack on Titan',
  'Attack on Titan Season 4': 'Attack on Titan',
  'Attack on Titan Final Season': 'Attack on Titan',
  'Dragon Ball Super': 'Dragon Ball',
  'Dragon Ball Z': 'Dragon Ball',
  'Dragon Ball GT': 'Dragon Ball',
  'Boku no Hero Academia': 'My Hero Academia',
  'My Hero Academia': 'Boku no Hero Academia',
  'Jujutsu Kaisen': 'Jujutsu Kaisen',
  'Jujutsu Kaisen 0': 'Jujutsu Kaisen',
  'One Piece': 'One Piece',
  'One Piece Film': 'One Piece',
  'One Piece Movie': 'One Piece',
  'One Piece Special': 'One Piece',
};

// FONCTIONS DE RESOLUTION CANONIQUE (inchangées)
function getCanonicalTitle(title) {
  if (!title) return title;
  const baseTitle = extractBaseFranchiseName(title);
  const titlesToTest = Array.from(new Set([baseTitle, title].filter(Boolean)));
  for (const testTitle of titlesToTest) {
      for (const [variant, canonical] of Object.entries(canonicalTitleMap)) {
          if (stripDiacritics(testTitle).toLowerCase().includes(stripDiacritics(variant).toLowerCase())) {
              return canonical;
          }
      }
      if (Object.values(canonicalTitleMap).includes(testTitle)) {
          return testTitle;
      }
      const titleLower = stripDiacritics(testTitle).toLowerCase();
      if (titleLower.includes('naruto')) return 'Naruto';
      if (titleLower.includes('dragon ball') || titleLower.includes('ballerz')) return 'Dragon Ball';
      if (titleLower.includes('attack on titan') || titleLower.includes('shingeki no kyojin')) return 'Attack on Titan';
      if (titleLower.includes('one piece')) return 'One Piece';
      if (titleLower.includes('my hero academia') || titleLower.includes('boku no hero')) return 'My Hero Academia';
  }
  return baseTitle;
}


// HELPERS AMÉLIORÉS POUR LA RECHERCHE DE FRANCHISES (inchangés)
function stripDiacritics(s = "") {
  return s.normalize?.("NFD").replace(/[\u0300-\u036f]/g, "") ?? s;
}

function extractBaseFranchiseName(title) {
  if (!title) return "";
  let cleanTitle = stripDiacritics(title).toLowerCase().trim();
  const patterns = [
    /\s*(saison|season|s|partie|part|part)\s*\d+/gi,
    /\s*(film|movie|ova|ona|special|tv|edition|uncut|uncensored|:|-|—)\s*\d*/gi,
    /\s*(the movie|the special|the ova|the ona)\s*/gi,
    /\s*(début|fin|partie|final|commencement|conclusion)\s*/gi,
    /\s*(épisode|episode|ep)\s*\d+/gi,
    /\s*\d+(?:ème|eme|nd|rd|th)?\s*(saison|season)/gi,
    /\s*(vol|volume)\s*\d+/gi,
    /\s*(chapitre|chapter)\s*\d+/gi,
    /\s*(arc)\s*\d+/gi,
    /\s*\(\d{4}\)\s*/gi,
    /\s*\[.*?\]\s*/gi,
    /\s*\(.*?\)\s*/gi,
    /\s*:\s*/gi,
    /\s*-\s*/gi,
    /\s*—\s*/gi,
    /\s*\|\s*/gi,
    /\s+\(TV\)\s*/gi,
    /\s+\(Movie\)\s*/gi,
    /\s+\(Special\)\s*/gi,
  ];
  patterns.forEach(pattern => {
    cleanTitle = cleanTitle.replace(pattern, ' ');
  });
  cleanTitle = cleanTitle.replace(/[:\-_.,!?'"]/g, ' ').replace(/\s+/g, ' ').trim();
  return cleanTitle;
}

function normalizeTitleForSeasonKey(title) {
  if (!title) return "";
  const baseTitle = extractBaseFranchiseName(title);
  return baseTitle.replace(/[\[\]\(\):_.,'™!¡?¿]/g, " ").replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-+|-+$/g, "").trim();
}

function buildIdCandidatesFromTitles(titles = []) {
  const ids = new Set();
  titles.filter(Boolean).forEach((title) => {
    const originalSlug = normalizeTitleForSeasonKey(title);
    if (originalSlug) {
      ids.add(originalSlug);
      ids.add(originalSlug.replace(/-/g, ""));
    }
    const franchiseSlug = normalizeTitleForSeasonKey(extractBaseFranchiseName(title));
    if (franchiseSlug && franchiseSlug !== originalSlug) {
      ids.add(franchiseSlug);
      ids.add(franchiseSlug.replace(/-/g, ""));
    }
    const specialNumPatterns = [
      { from: /\b(?:no|n°|number)\s*\.?\s*(\d+)/gi, to: "n$1" },
      { from: /\b(?:no|n°|number)\s*\.?\s*(\d+)/gi, to: "-$1" },
      { from: /\b(?:no|n°|number)\s*\.?\s*(\d+)/gi, to: "-no-$1" }
    ];
    specialNumPatterns.forEach(pattern => {
      const modifiedTitle = title.toLowerCase().replace(pattern.from, pattern.to);
      if (modifiedTitle !== title.toLowerCase()) {
        const specialSlug = normalizeTitleForSeasonKey(modifiedTitle);
        if (specialSlug) {
          ids.add(specialSlug);
          ids.add(specialSlug.replace(/-/g, ""));
        }
      }
    });
    const firstPart = title.split(/[\s:-]/).filter(Boolean)[0];
    if (firstPart && firstPart.length > 3) {
      const firstPartSlug = normalizeTitleForSeasonKey(firstPart);
      if (firstPartSlug) {
        ids.add(firstPartSlug);
        ids.add(firstPartSlug.replace(/-/g, ""));
      }
    }
  });
  return Array.from(ids);
}

function generateTitleVariants(titles) {
  const variants = new Set();
  titles.filter(Boolean).forEach(title => {
    if (!title) return;
    variants.add(title);
    const baseTitle = extractBaseFranchiseName(title);
    if (baseTitle) {
      variants.add(baseTitle);
    }
    const normalized = normalizeTitleForSeasonKey(title);
    if (normalized) variants.add(normalized);
    const franchiseNormalized = normalizeTitleForSeasonKey(baseTitle);
    if (franchiseNormalized && franchiseNormalized !== normalized) {
      variants.add(franchiseNormalized);
    }
    if (normalized) {
      const collapsed = normalized.replace(/-/g, '');
      if (collapsed) variants.add(collapsed);
    }
    const firstWord = title.split(/[\s:-]/).filter(Boolean)[0];
    if (firstWord && firstWord.length > 3) {
      variants.add(firstWord);
      const firstWordNormalized = normalizeTitleForSeasonKey(firstWord);
      if (firstWordNormalized) variants.add(firstWordNormalized);
    }
    const canonicalTitle = getCanonicalTitle(title);
    if (canonicalTitle && canonicalTitle !== title && canonicalTitle !== baseTitle) {
      variants.add(canonicalTitle);
      variants.add(normalizeTitleForSeasonKey(canonicalTitle));
    }
    const withoutCommonWords = title.replace(/\b(the|le|la|les|un|une|des|de|du)\b/gi, '').replace(/\s+/g, ' ').trim();
    if (withoutCommonWords && withoutCommonWords !== title) {
      variants.add(withoutCommonWords);
    }
  });
  return Array.from(variants).filter(Boolean);
}

// FONCTIONS EXISTANTES (inchangées)
function normalizeEpisodeLanguages(e = {}) {
  const out = {};
  if (!e || typeof e !== "object") return out;
  const push = (k, v) => {
    if (!k || v == null) return;
    const kk = String(k).toUpperCase();
    if (!out[kk]) out[kk] = [];
    if (Array.isArray(v)) v.forEach(x => { if (x) out[kk].push(String(x)); });
    else if (typeof v === "string") out[kk].push(v);
    else if (typeof v === "object") {
      const arr = Object.values(v).filter(Boolean).map(String);
      arr.forEach(x => out[kk].push(x));
    }
  };
  if (e.languages && typeof e.languages === "object") {
    for (const k of Object.keys(e.languages)) push(k, e.languages[k]);
  }
  if (e.LANGUAGES && typeof e.LANGUAGES === "object") {
    for (const k of Object.keys(e.LANGUAGES)) push(k, e.LANGUAGES[k]);
  }
  const TOP_KEYS = ['VOSTFR','VF','FR','VOST','SUB','DEFAULT','VO'];
  for (const k of TOP_KEYS) {
    if (e[k]) push(k, e[k]);
  }
  return out;
}

function pickBestUrlFromEpisode(ep = {}, preferredLangs = ["VOSTFR","VF","FR","VO","SUB","DEFAULT"]) {
  if (!ep) return null;
  if (ep.url) return ep.url;
  if (ep.video) return ep.video;
  if (ep.link) return ep.link;
  const normalized = normalizeEpisodeLanguages(ep);
  const isValidVideoUrl = (url) => {
    if (!url || typeof url !== 'string') return false;
    const invalidPatterns = [/^intent:\/\//i, /ak\.amskiploomr\.com/i, /doubleclick\.net/i, /googlesyndication\.com/i, /adservice\.google\.com/i, /ads\./i, /tracker\./i, /analytics\./i, /pixel\./i, /beacon\./i];
    return !invalidPatterns.some(pattern => pattern.test(url));
  };
  const preferredHosts = ['sibnet.ru', 'sendvid.com', 'vk.com', 'vidmoly.net'];
  for (const lang of preferredLangs) {
    const arr = normalized[lang];
    if (!arr || !arr.length) continue;
    for (const url of arr) {
      if (url && isValidVideoUrl(url) && preferredHosts.some(host => url.includes(host))) {
        return url;
      }
    }
    for (const url of arr) {
      if (url && isValidVideoUrl(url)) {
        return url;
      }
    }
  }
  for (const k of Object.keys(normalized)) {
    for (const url of normalized[k]) {
      if (url && isValidVideoUrl(url)) {
        return url;
      }
    }
  }
  return null;
}

function parseDocDataToSeasons(docData = {}, fallbackTitle = "Episode") {
  const seasons = [];
  const flat = [];
  if (docData?.episodes && typeof docData.episodes === "object" && !Array.isArray(docData.episodes)) {
    console.log("📊 Structure episodes détectée:", Object.keys(docData.episodes));
    for (const [seasonName, arr] of Object.entries(docData.episodes)) {
      if (!Array.isArray(arr)) continue;
      console.log(`🔍 Traitement ${seasonName}:`, arr.length, "épisodes");
      const eps = arr.map((e, idx) => {
        const number = e.index ?? e.number ?? idx + 1;
        const title = e.name ?? e.title ?? `Episode ${number}`;
        const languages = {};
        if (e.languages && typeof e.languages === "object") {
          Object.entries(e.languages).forEach(([lang, urls]) => {
            const langKey = lang.toUpperCase();
            if (Array.isArray(urls)) {
              languages[langKey] = urls.filter(url => url && typeof url === 'string');
            }
          });
        }
        const ep = { id: `${seasonName}-${number}`, number, title, languages, date: e.release_date ?? e.date ?? null, thumbnail: e.thumbnail, seasonName };
        flat.push(ep);
        return ep;
      });
      seasons.push({ season: seasonName, episodes: eps, episodeCount: eps.length });
    }
  }
  seasons.sort((a, b) => {
    const aNum = parseInt((a.season.match(/\d+/) || [0])[0]);
    const bNum = parseInt((b.season.match(/\d+/) || [0])[0]);
    return aNum - bNum;
  });
  console.log("✅ Parsing terminé:", { seasonsCount: seasons.length, totalEpisodes: flat.length, seasons: seasons.map(s => ({ name: s.season, count: s.episodeCount })) });
  return { seasons, flat };
}
// EXTRACTION SERVEUR RENDER (inchangée)
const extractWithRenderServer = async (sourceUrl) => {
  try {
    console.log("🚀 Extraction serveur Render pour:", sourceUrl.slice(0, 50) + "...");
    const response = await fetch(`${RENDER_SERVER_URL}/extract`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
      body: JSON.stringify({ url: sourceUrl, timeout: 45 }),
    });
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Serveur Render statut ${response.status}: ${errorText}`);
    }
    const result = await response.json();
    if (!result.success) {
      throw new Error(result.error || 'Extraction échouée');
    }
    const resultUrl = result.stream_url || result.extracted_url || result.url;
    if (!resultUrl) {
      throw new Error('Aucune URL de stream retournée par le serveur');
    }
    console.log("✅ Extraction Render réussie:", resultUrl.slice(0, 50) + "...");
    return { url: resultUrl, success: true, method: 'render-yt-dlp-server', isDirectVideo: result.is_direct || false, ext: result.ext || null };
  } catch (error) {
    console.error("❌ Erreur extraction serveur Render:", error);
    return { success: false, error: error.message || 'Erreur inconnue du serveur Render' };
  }
};
// FIRESTORE HELPERS AMÉLIORÉS (inchangés)
async function tryFetchFromFirestore(titleVariants = []) {
  try {
    const collectionNames = ["animeDetails", "animesDetails", "animesDetail", "anime", "animes", "animes_details"];
    const ids = buildIdCandidatesFromTitles(titleVariants);
    console.log("🔍 V2.4 Recherche avec variantes:", titleVariants.slice(0, 3));
    console.log("🔍 V2.4 IDs candidats:", ids.slice(0, 5));
    for (const colName of collectionNames) {
      try {
        for (const id of ids) {
          try {
            const snap = await getDoc(doc(db, colName, id));
            if (snap.exists()) {
              console.log(`✅ V2.4 Trouvé par ID direct: ${colName}/${id}`);
              return { id: snap.id, data: snap.data(), collection: colName };
            }
          } catch (e) { continue; }
        }
      } catch (e) {}
    }
    for (const colName of collectionNames) {
      try {
        const colRef = collection(db, colName);
        const snap = await getDocs(colRef);
        const normalizedVariants = titleVariants.map(t => extractBaseFranchiseName(t)).filter(Boolean).map(t => t.toLowerCase());
        for (const d of snap.docs) {
          const dat = d.data();
          const docNormalized = (dat.normalized || d.id || "").toLowerCase();
          if (normalizedVariants.some(variant => {
            const pattern = new RegExp("^" + variant.replace(/[-\s]/g, "[- ]?") + "$", "i");
            return pattern.test(docNormalized);
          })) {
            console.log(`✅ V2.4 Trouvé par normalized: ${colName}/${d.id}`);
            return { id: d.id, data: dat, collection: colName };
          }
          const titlesAll = Array.isArray(dat.titlesAll) ? dat.titlesAll : (Array.isArray(dat.title_variants) ? dat.title_variants : []);
          for (const variant of titleVariants) {
            const variantBase = extractBaseFranchiseName(variant);
            if (titlesAll && titlesAll.some((t) => {
              const tBase = extractBaseFranchiseName(String(t || ""));
              return tBase.toLowerCase() === variantBase.toLowerCase() || String(t || "").toLowerCase() === String(variant || "").toLowerCase();
            })) {
              console.log(`✅ V2.4 Trouvé par titlesAll: ${colName}/${d.id}`);
              return { id: d.id, data: dat, collection: colName };
            }
          }
          const mainTitle = dat.title || dat.name || "";
          if (mainTitle) {
            const mainTitleBase = extractBaseFranchiseName(mainTitle);
            if (normalizedVariants.some(variant => mainTitleBase.toLowerCase().includes(variant) || variant.includes(mainTitleBase.toLowerCase()))) {
              console.log(`✅ V2.4 Trouvé par fuzzy match: ${colName}/${d.id}`);
              return { id: d.id, data: dat, collection: colName };
            }
          }
        }
      } catch (e) {
        console.log(`❌ V2.4 Erreur scan ${colName}:`, e.message);
      }
    }
  } catch (e) {
    console.log("❌ V2.4 Erreur générale Firestore:", e.message);
  }
  return null;
}

const testRenderServerConnectivity = async () => {
  try {
    const response = await fetch(`${RENDER_SERVER_URL}/`, { method: 'GET', timeout: 10000 });
    if (response.ok) {
      const text = await response.text();
      return { success: true, message: text || 'Serveur opérationnel', status: response.status };
    }
    return { success: false, message: `Statut HTTP: ${response.status}`, status: response.status };
  } catch (error) {
    console.error('❌ Erreur connexion serveur:', error);
    return { success: false, error: error.message || 'Impossible de contacter le serveur', status: null };
  }
};
// COMPOSANT PRINCIPAL
export default function AnimeDetailsScreenV2() {
  const navigation = useNavigation();
  const route = useRoute();
  // MODIFICATION: Renommé pour plus de clarté
  const initialAnimeFromRoute = route?.params?.anime || {};
  
  // MODIFICATION: L'état principal qui contiendra les données d'affichage (franchise + épisodes)
  const [animeData, setAnimeData] = useState(initialAnimeFromRoute);
  
  const [episodes, setEpisodes] = useState([]);
  const [seasons, setSeasons] = useState([]);
  const [selectedSeason, setSelectedSeason] = useState('Saison 1');
  const [selectedLanguage, setSelectedLanguage] = useState('VOSTFR');
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [isInWatchlist, setIsInWatchlist] = useState(false);
  const [selectedTab, setSelectedTab] = useState('episodes');
  const [expandedDescription, setExpandedDescription] = useState(false);
  const [resolving, setResolving] = useState(false);
  const [resolvingMsg, setResolvingMsg] = useState("");
  const scrollY = useRef(new Animated.Value(0)).current;
  const headerOpacity = scrollY.interpolate({
    inputRange: [0, 200],
    outputRange: [0, 1],
    extrapolate: 'clamp',
  });

  // MODIFICATION: Ces `useMemo` dépendent maintenant de `animeData` pour l'affichage
  const title = useMemo(() =>
    animeData.title || animeData.title_romaji || animeData.title_en || "—",
    [animeData]
  );

  const poster = useMemo(() =>
    animeData.posterImage || animeData.bannerImage || animeData.image || "",
    [animeData]
  );
  
  // MODIFICATION: Le titre canonique est toujours calculé à partir de l'objet initial
  const canonicalTitle = useMemo(() => {
    const titleVariants = [
      initialAnimeFromRoute.title,
      initialAnimeFromRoute.title_en,
      initialAnimeFromRoute.title_romaji,
      initialAnimeFromRoute.title_native,
      ...(initialAnimeFromRoute.synonyms || []),
      ...(initialAnimeFromRoute.title_variants || [])
    ].filter(Boolean);
    const primaryTitle = titleVariants[0] || "";
    return getCanonicalTitle(primaryTitle);
  }, [initialAnimeFromRoute]);

  const loadAnimeData = useCallback(async () => {
    try {
      setLoading(true);
      console.log("📡 V2.4 Chargement des données pour:", initialAnimeFromRoute.title);
      console.log("🏷️ Titre canonique détecté:", canonicalTitle);

      // --- NOUVELLE LOGIQUE ---
      // Étape 1 : Récupérer les détails de la franchise pour un affichage correct
      const franchiseData = await fetchFranchiseDetails(canonicalTitle);
      
      // Étape 2 : Créer l'objet de données principal pour l'affichage.
      // On garde les données initiales en fallback, mais on les écrase avec les données de la franchise si elles existent.
      const masterDisplayData = { ...initialAnimeFromRoute, ...(franchiseData || {}) };
      setAnimeData(masterDisplayData); // Mettre à jour l'affichage immédiatement !
      // --- FIN DE LA NOUVELLE LOGIQUE ---
      
      const titleVariants = generateTitleVariants([
        initialAnimeFromRoute.title,
        canonicalTitle,
        initialAnimeFromRoute.title_en,
        initialAnimeFromRoute.title_romaji,
        initialAnimeFromRoute.title_native,
        ...(initialAnimeFromRoute.synonyms || []),
        ...(initialAnimeFromRoute.title_variants || [])
      ]);

      console.log("🔍 V2.4 Variantes générées:", titleVariants.slice(0, 5));

      let providerRes = null;
      providerRes = await fetchEpisodesByTitle(canonicalTitle);

      if ((!providerRes || !Array.isArray(providerRes) || providerRes.length === 0) && canonicalTitle !== initialAnimeFromRoute.title) {
        console.log("🔄 V2.4 Retry avec titre original:", initialAnimeFromRoute.title);
        providerRes = await fetchEpisodesByTitle(initialAnimeFromRoute.title);
      }
      
      // ... la suite de la logique de recherche d'épisodes reste la même

      if (providerRes && Array.isArray(providerRes) && providerRes.length > 0) {
        // ...
        const hasUrls = flat.some(ep => Object.keys(ep.languages || {}).length > 0);
        if (hasUrls) {
          console.log("✅ V2.4 Données API trouvées");
          setSeasons(seasonsArr);
          setEpisodes(flat);
          const idxS1 = seasonsArr.findIndex(s => /^saison\s*1/i.test(s.season));
          if (idxS1 >= 0) setSelectedSeason(seasonsArr[idxS1].season);
          // MODIFICATION: On ajoute les épisodes aux données d'affichage déjà définies
          setAnimeData(currentData => ({ ...currentData, episodes: flat, seasons: seasonsArr }));
          setLoading(false);
          return;
        }
      }

      let docFound = null;
      if (initialAnimeFromRoute.id) {
        // ...
      }

      if (!docFound) {
        docFound = await tryFetchFromFirestore([canonicalTitle, initialAnimeFromRoute.title, ...titleVariants.slice(0, 3)]);
      }

      if (docFound && docFound.data) {
        const parsed = parseDocDataToSeasons(docFound.data, canonicalTitle);
        if (parsed.seasons.length > 0) {
          console.log("✅ V2.4 Données Firestore trouvées");
          setSeasons(parsed.seasons);
          setEpisodes(parsed.flat);
          setSelectedSeason(parsed.seasons[0].season);
          // MODIFICATION: On fusionne les données de Firestore avec les données d'affichage
          setAnimeData(currentData => ({
            ...currentData,
            ...docFound.data,
            episodes: parsed.flat,
            seasons: parsed.seasons,
            episodesCount: parsed.flat.length
          }));
          setLoading(false);
          return;
        }
      }

      // ... logique de dernier recours

      console.log("❌ V2.4 Aucune donnée trouvée");
      setSeasons([]);
      setEpisodes([]);
      
    } catch (error) {
      console.error('V2.4 Erreur chargement anime:', error);
      Alert.alert(
        'Erreur de chargement',
        `Impossible de charger les informations pour "${title}". Réessayer ?`,
        [{ text: 'Annuler', style: 'cancel' }, { text: 'Réessayer', onPress: loadAnimeData }]
      );
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  }, [initialAnimeFromRoute, canonicalTitle]);

  useEffect(() => {
    loadAnimeData();
  }, [loadAnimeData]);

  // FONCTION DE LECTURE (inchangée)
  const onPlayEpisode = async (episode) => {
    console.log('🎬 Tentatives de lecture pour l\'épisode:', episode.title);
    try {
        const languages = Object.keys(episode.languages || {});
        const preferredLanguages = [selectedLanguage, "VOSTFR", "VF", "FR", "VO", "SUB", "DEFAULT"];
        const validLanguages = languages.filter(lang => preferredLanguages.includes(lang));
        const unsupportedDomains = ['vidmoly.net', 'ak.amskiploomr.com'];

        for (const lang of validLanguages) {
            const urls = episode.languages[lang] || [];
            for (const url of urls) {
                if (!url) continue;
                try {
                    const domain = new URL(url).hostname;
                    if (unsupportedDomains.some(d => domain.includes(d))) {
                        console.log(`✗ Skip: ${domain} non supporté`);
                        continue;
                    }
                } catch (e) {
                    console.log(`✗ URL invalide: ${url}`);
                    continue;
                }
                console.log(`→ Tentative: ${lang} - ${url.slice(0, 50)}...`);
                try {
                    const response = await fetch(`${RENDER_SERVER_URL}/extract`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                        body: JSON.stringify({ url: url, timeout: 45 }),
                    });
                    const contentType = response.headers.get("content-type");
                    if (!contentType || !contentType.includes("application/json")) {
                        console.error(`✗ Réponse non-JSON reçue (${contentType})`);
                        const text = await response.text();
                        console.error(`Contenu reçu: ${text.slice(0, 200)}...`);
                        continue;
                    }
                    const result = await response.json();
                    if (result.success && result.stream_url) {
                        console.log(`✅ Extraction réussie: ${result.stream_url.slice(0, 50)}...`);
                        navigation.navigate("Player", {
                            episode: {
                                ...episode,
                                url: result.stream_url,
                                languages: { [lang]: [result.stream_url] },
                                anime: animeData // On passe les données complètes de l'anime
                            }
                        });
                        return;
                    } else {
                        console.log(`✗ Extraction échouée:`, result.error || 'Pas d\'URL retournée');
                    }
                } catch (error) {
                    console.error(`✗ Erreur réseau/parsing pour ${url.slice(0, 50)}:`, error.message);
                }
            }
        }
        throw new Error("Aucun lien n'a fonctionné");
    } catch (error) {
        console.error("✗ Erreur globale:", error);
        Alert.alert(
            "Erreur de lecture",
            "Impossible de lire cet épisode. Vérifiez votre connexion ou réessayez plus tard.",
            [{ text: "Annuler", style: "cancel" }, { text: "Réessayer", onPress: () => onPlayEpisode(episode) }]
        );
    }
  };

  // Le reste du fichier (fonctions de rendu, styles) est inchangé
  // ...
  // ...
  
  // Dans renderDescription, utiliser animeData
  const renderDescription = () => {
    const description = (animeData?.description) || "";
    // ...
  };
  
  // Dans renderDetailsContent, utiliser animeData
  const renderDetailsContent = () => (
    <View style={styles.detailsContainer}>
      <Text style={styles.sectionTitle}>Informations</Text>
      <View style={styles.detailsGrid}>
        <View style={styles.detailItem}>
          <Text style={styles.detailLabel}>Créateur</Text>
          <Text style={styles.detailValue}>{animeData?.studio || "—"}</Text>
        </View>
        <View style={styles.detailItem}>
          <Text style={styles.detailLabel}>Genre</Text>
          <Text style={styles.detailValue}>
            {Array.isArray(animeData?.genres) ? animeData.genres.join(", ") : "Animation"}
          </Text>
        </View>
        <View style={styles.detailItem}>
          <Text style={styles.detailLabel}>Année</Text>
          <Text style={styles.detailValue}>{animeData?.year || "—"}</Text>
        </View>
        <View style={styles.detailItem}>
          <Text style={styles.detailLabel}>Statut</Text>
          <Text style={styles.detailValue}>{animeData?.status || "—"}</Text>
        </View>
        <View style={styles.detailItem}>
          <Text style={styles.detailLabel}>Titre franchise</Text>
          <Text style={styles.detailValue}>{canonicalTitle}</Text>
        </View>
        <View style={styles.detailItem}>
          <Text style={styles.detailLabel}>Source de données</Text>
          <Text style={styles.detailValue}>
            {animeData?.collection ? `Firestore (${animeData.collection})` : "API"}
          </Text>
        </View>
      </View>
    </View>
  );
  
  // Le reste du composant (renderHeader, renderHeroSection, etc.) utilise déjà `title` et `poster`
  // qui sont maintenant dérivés de `animeData`, donc aucune autre modification n'est nécessaire là-bas.

  // Le reste du fichier est ici, inchangé...
  const testServerConnectivity = async () => {
    try {
        const response = await fetch(`${RENDER_SERVER_URL}/health`, {
            method: 'GET',
            headers: { 'Accept': 'application/json' },
        });

        if (response.ok) {
            const data = await response.json();
            console.log('✅ Serveur Render OK:', data);
            return { success: true, ...data };
        }

        return { success: false, status: response.status };
    } catch (error) {
        console.error('❌ Erreur connexion serveur:', error);
        return { success: false, error: error.message };
    }
  };

  const filteredEpisodes = useMemo(() => {
    const season = seasons.find(s => s.season === selectedSeason);
    return season ? season.episodes : [];
  }, [seasons, selectedSeason]);

  const availableLanguages = useMemo(() => {
    const languages = new Set();
    episodes.forEach(ep => {
      Object.keys(ep.languages || {}).forEach(lang => {
        languages.add(lang);
      });
    });
    return Array.from(languages);
  }, [episodes]);

  const renderEpisodesStats = () => (
    <View style={styles.statsContainer}>
      <Text style={styles.statsText}>
        📊 {episodes.length} épisodes • {seasons.length} saison{seasons.length > 1 ? 's' : ''}
      </Text>
      <Text style={styles.statsSubtext}>
        Langue sélectionnée: {selectedLanguage}
      </Text>
    </View>
  );

  const renderHeader = () => (
    <Animated.View style={[styles.header, { backgroundColor: headerOpacity.interpolate({ inputRange: [0, 1], outputRange: ['transparent', COLORS.background] }) }]}>
      <View style={styles.headerContent}>
        <TouchableOpacity onPress={() => navigation.goBack()}>
          <Ionicons name="arrow-back" size={24} color={COLORS.text} />
        </TouchableOpacity>
        <Text style={styles.headerTitle} numberOfLines={1}>{title}</Text>
        <View style={styles.headerActions}>
          <TouchableOpacity>
            <Ionicons name="share-outline" size={24} color={COLORS.text} />
          </TouchableOpacity>
        </View>
      </View>
    </Animated.View>
  );

  const renderHeroSection = () => (
    <View style={styles.heroContainer}>
      <Image source={{ uri: poster }} style={styles.heroPoster} resizeMode="cover" />
      <LinearGradient
        colors={['transparent', 'rgba(11,11,11,0.8)', COLORS.background]}
        style={styles.heroGradient}
      />
      <View style={styles.heroContent}>
        <View style={styles.heroInfo}>
          <Text style={styles.heroTitle} numberOfLines={2}>{title}</Text>
          {canonicalTitle !== title && (
            <Text style={[styles.heroCanonicalTitle, styles.metaText]}>
              Franchise: {canonicalTitle}
            </Text>
          )}
          <View style={styles.heroMeta}>
            <View style={styles.ratingBadge}>
              <Text style={styles.ratingText}>16+</Text>
            </View>
            <Text style={styles.metaText}>Animation</Text>
            <Text style={styles.metaText}>HD</Text>
          </View>
          <View style={styles.heroActions}>
            <TouchableOpacity
              style={styles.playButton}
              onPress={() => filteredEpisodes[0] && onPlayEpisode(filteredEpisodes[0])}
              disabled={!filteredEpisodes.length || resolving}
            >
              <Ionicons name="play" size={20} color={COLORS.background} />
              <Text style={styles.playButtonText}>LECTURE</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[styles.actionButton, isInWatchlist && styles.actionButtonActive]}
              onPress={() => setIsInWatchlist(!isInWatchlist)}
            >
              <Ionicons
                name={isInWatchlist ? "checkmark" : "add"}
                size={20}
                color={isInWatchlist ? COLORS.success : COLORS.text}
              />
              <Text style={[styles.actionButtonText, isInWatchlist && styles.actionButtonTextActive]}>
                {isInWatchlist ? "AJOUTÉ" : "MA LISTE"}
              </Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </View>
  );

  const renderTabs = () => (
    <View style={styles.tabsContainer}>
      <TouchableOpacity
        style={[styles.tab, selectedTab === 'episodes' && styles.activeTab]}
        onPress={() => setSelectedTab('episodes')}
      >
        <Text style={[styles.tabText, selectedTab === 'episodes' && styles.activeTabText]}>
          ÉPISODES
        </Text>
      </TouchableOpacity>
      <TouchableOpacity
        style={[styles.tab, selectedTab === 'similar' && styles.activeTab]}
        onPress={() => setSelectedTab('similar')}
      >
        <Text style={[styles.tabText, selectedTab === 'similar' && styles.activeTabText]}>
          SIMILAIRES
        </Text>
      </TouchableOpacity>
      <TouchableOpacity
        style={[styles.tab, selectedTab === 'details' && styles.activeTab]}
        onPress={() => setSelectedTab('details')}
      >
        <Text style={[styles.tabText, selectedTab === 'details' && styles.activeTabText]}>
          DÉTAILS
        </Text>
      </TouchableOpacity>
    </View>
  );

  const renderSeasonSelector = () => {
    if (seasons.length <= 1) return null;
    return (
      <View style={styles.seasonSelector}>
        <Text style={styles.sectionTitle}>Saison</Text>
        <ScrollView horizontal showsHorizontalScrollIndicator={false}>
          {seasons.map((season) => (
            <TouchableOpacity
              key={season.season}
              style={[
                styles.seasonChip,
                selectedSeason === season.season && styles.selectedSeasonChip
              ]}
              onPress={() => setSelectedSeason(season.season)}
            >
              <Text style={[
                styles.seasonChipText,
                selectedSeason === season.season && styles.selectedSeasonChipText
              ]}>
                {season.season}
              </Text>
            </TouchableOpacity>
          ))}
        </ScrollView>
      </View>
    );
  };

  const renderLanguageSelector = () => {
    if (availableLanguages.length <= 1) return null;
    return (
      <View style={styles.languageSelector}>
        <Text style={styles.sectionTitle}>Langue</Text>
        <ScrollView horizontal showsHorizontalScrollIndicator={false}>
          {availableLanguages.map((lang) => (
            <TouchableOpacity
              key={lang}
              style={[
                styles.languageChip,
                selectedLanguage === lang && styles.selectedLanguageChip
              ]}
              onPress={() => setSelectedLanguage(lang)}
            >
              <Text style={[
                styles.languageChipText,
                selectedLanguage === lang && styles.selectedLanguageChipText
              ]}>
                {lang}
              </Text>
            </TouchableOpacity>
          ))}
        </ScrollView>
      </View>
    );
  };

  const renderEpisodeItem = ({ item: episode, index }) => (
    <TouchableOpacity
      style={styles.episodeItem}
      onPress={() => onPlayEpisode(episode)}
      activeOpacity={0.7}
      disabled={resolving}
    >
      <View style={styles.episodeThumb}>
        <Image
          source={{ uri: episode.thumbnail || poster }}
          style={styles.episodeImage}
          resizeMode="cover"
        />
        <View style={styles.playOverlay}>
          <Ionicons name="play-circle" size={40} color="rgba(255,255,255,0.8)" />
        </View>
        <View style={styles.episodeDuration}>
          <Text style={styles.durationText}>24m</Text>
        </View>
      </View>
      <View style={styles.episodeInfo}>
        <Text style={styles.episodeTitle} numberOfLines={2}>
          {episode.number}. {episode.title}
        </Text>
        <Text style={styles.episodeDescription} numberOfLines={2}>
          {episode.description || `Episode ${episode.number} de ${title}`}
        </Text>
        <Text style={styles.episodeDate}>
          {episode.date ? new Date(episode.date).toLocaleDateString('fr-FR') : ''}
        </Text>
      </View>
      <View style={styles.episodeActions}>
        <TouchableOpacity>
          <Ionicons name="download-outline" size={20} color={COLORS.textMuted} />
        </TouchableOpacity>
      </View>
    </TouchableOpacity>
  );

  const renderEpisodesList = () => (
    <View style={styles.episodesContainer}>
      {renderLanguageSelector()}
      {renderEpisodesStats()}
      <View style={styles.episodesHeader}>
        <Text style={styles.sectionTitle}>
          {selectedSeason} ({filteredEpisodes.length} épisodes)
        </Text>
        <View style={styles.headerActions}>
          <TouchableOpacity
            style={styles.debugButton}
            onPress={async () => {
              console.log("Debug V2.4 - Episodes chargés:", episodes.length);
              console.log("Debug V2.4 - Episodes filtrés:", filteredEpisodes.length);
              console.log("Debug V2.4 - Titre original:", title);
              console.log("Debug V2.4 - Titre canonique:", canonicalTitle);
              console.log("Debug V2.4 - Premier épisode:", filteredEpisodes[0]);
              const serverTest = await testRenderServerConnectivity();
              console.log("Test serveur Render:", serverTest);
              Alert.alert(
                "Debug Info V2.4",
                `Titre: ${title}\n` +
                `Franchise: ${canonicalTitle}\n` +
                `Episodes chargés: ${episodes.length}\n` +
                `Episodes filtrés: ${filteredEpisodes.length}\n\n` +
                `Serveur Render: ${serverTest.success ? 'OK' : 'Erreur'}\n` +
                `URL: ${RENDER_SERVER_URL}\n` +
                `Statut: ${serverTest.status || 'N/A'}`
              );
            }}
          >
            <MaterialIcons name="bug-report" size={12} color={COLORS.background} />
            <Text style={styles.debugButtonText}>Debug V2.4</Text>
          </TouchableOpacity>
        </View>
      </View>
      {filteredEpisodes.length === 0 ? (
        <View style={styles.emptyState}>
          <MaterialIcons name="video-library" size={48} color={COLORS.textMuted} />
          <Text style={styles.emptyStateText}>Aucun épisode trouvé</Text>
          <Text style={styles.emptyStateSubtext}>
            Vérifiez votre connexion ou réessayez plus tard
          </Text>
          <TouchableOpacity
            style={styles.retryButton}
            onPress={loadAnimeData}
          >
            <Text style={styles.retryButtonText}>Réessayer</Text>
          </TouchableOpacity>
        </View>
      ) : (
        <FlatList
          data={filteredEpisodes}
          renderItem={renderEpisodeItem}
          keyExtractor={(item) => item.id}
          showsVerticalScrollIndicator={false}
          scrollEnabled={false}
        />
      )}
    </View>
  );

  const renderSimilarContent = () => (
    <View style={styles.similarContainer}>
      <Text style={styles.sectionTitle}>Titres similaires</Text>
      <View style={styles.similarGrid}>
        {Array.from({ length: 6 }, (_, i) => (
          <TouchableOpacity key={i} style={styles.similarItem}>
            <View style={styles.similarPoster} />
            <Text style={styles.similarTitle}>Anime similaire {i + 1}</Text>
          </TouchableOpacity>
        ))}
      </View>
    </View>
  );

  const renderContent = () => {
    switch (selectedTab) {
      case 'episodes':
        return renderEpisodesList();
      case 'similar':
        return renderSimilarContent();
      case 'details':
        return renderDetailsContent();
      default:
        return renderEpisodesList();
    }
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={COLORS.primary} />
        <Text style={styles.loadingText}>Chargement V2.4...</Text>
        <Text style={styles.loadingSubtext}>Recherche intelligente de franchise</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <StatusBar barStyle="light-content" backgroundColor="transparent" translucent />
      <Animated.ScrollView
        style={styles.scrollView}
        onScroll={Animated.event(
          [{ nativeEvent: { contentOffset: { y: scrollY } } }],
          { useNativeDriver: false }
        )}
        scrollEventThrottle={16}
      >
        {renderHeroSection()}
        {renderDescription()}
        {renderTabs()}
        {renderSeasonSelector()}
        {renderContent()}
      </Animated.ScrollView>
      {renderHeader()}
      {resolving && (
        <View style={styles.resolvingOverlay}>
          <BlurView intensity={20} style={styles.resolvingBlur}>
            <View style={styles.resolvingContent}>
              <ActivityIndicator size="large" color={COLORS.primary} />
              <Text style={styles.resolvingText}>
                {resolvingMsg || "Préparation V2.4..."}
              </Text>
              <Text style={styles.resolvingSubtext}>
                Serveur Render + Recherche franchise améliorée
              </Text>
            </View>
          </BlurView>
        </View>
      )}
    </View>
  );
}

// STYLES (inchangés)
const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: COLORS.background, },
  loadingContainer: { flex: 1, backgroundColor: COLORS.background, alignItems: 'center', justifyContent: 'center', },
  loadingText: { color: COLORS.textSecondary, fontSize: 16, marginTop: 16, },
  loadingSubtext: { color: COLORS.textMuted, fontSize: 12, marginTop: 8, },
  scrollView: { flex: 1, },
  header: { position: 'absolute', top: 0, left: 0, right: 0, zIndex: 10, paddingTop: Platform.OS === 'ios' ? 44 : StatusBar.currentHeight || 0, },
  headerContent: { flexDirection: 'row', alignItems: 'center', paddingHorizontal: 16, paddingVertical: 12, },
  headerTitle: { flex: 1, color: COLORS.text, fontSize: 18, fontWeight: '600', marginHorizontal: 16, },
  headerActions: { flexDirection: 'row', gap: 16, },
  heroContainer: { height: SCREEN_HEIGHT * 0.6, position: 'relative', },
  heroPoster: { width: '100%', height: '100%', resizeMode: 'cover', },
  heroGradient: { position: 'absolute', bottom: 0, left: 0, right: 0, height: '60%', },
  heroContent: { position: 'absolute', bottom: 0, left: 0, right: 0, padding: 20, },
  heroInfo: { alignItems: 'center', },
  heroTitle: { color: COLORS.text, fontSize: 28, fontWeight: '900', textAlign: 'center', marginBottom: 8, textShadowColor: 'rgba(0,0,0,0.8)', textShadowOffset: { width: 0, height: 2 }, textShadowRadius: 8, },
  heroCanonicalTitle: { color: COLORS.textSecondary, fontSize: 16, fontWeight: '500', marginBottom: 8, },
  heroMeta: { flexDirection: 'row', alignItems: 'center', marginBottom: 20, gap: 8, },
  ratingBadge: { backgroundColor: COLORS.surface, paddingHorizontal: 8, paddingVertical: 4, borderRadius: 4, },
  ratingText: { color: COLORS.text, fontSize: 12, fontWeight: '600', },
  metaText: { color: COLORS.textSecondary, fontSize: 14, },
  heroActions: { flexDirection: 'row', gap: 12, width: '100%', },
  playButton: { flex: 1, backgroundColor: COLORS.primary, paddingVertical: 12, paddingHorizontal: 24, borderRadius: 8, flexDirection: 'row', alignItems: 'center', justifyContent: 'center', gap: 8, },
  playButtonText: { color: COLORS.background, fontSize: 16, fontWeight: '700', },
  actionButton: { flex: 1, backgroundColor: 'transparent', borderWidth: 2, borderColor: COLORS.border, paddingVertical: 10, paddingHorizontal: 24, borderRadius: 8, flexDirection: 'row', alignItems: 'center', justifyContent: 'center', gap: 8, },
  actionButtonActive: { borderColor: COLORS.success, backgroundColor: 'rgba(76, 175, 80, 0.1)', },
  actionButtonText: { color: COLORS.text, fontSize: 16, fontWeight: '700', },
  actionButtonTextActive: { color: COLORS.success, },
  descriptionContainer: { paddingHorizontal: 20, paddingVertical: 12, },
  descriptionText: { color: COLORS.textSecondary, fontSize: 14, lineHeight: 20, marginBottom: 12, },
  tabsContainer: { flexDirection: 'row', paddingHorizontal: 20, marginBottom: 20, },
  tab: { flex: 1, paddingVertical: 12, alignItems: 'center', borderBottomWidth: 2, borderBottomColor: 'transparent', },
  activeTab: { borderBottomColor: COLORS.primary, },
  tabText: { color: COLORS.textMuted, fontSize: 14, fontWeight: '600', },
  activeTabText: { color: COLORS.primary, },
  sectionTitle: { color: COLORS.text, fontSize: 18, fontWeight: '700', marginBottom: 16, },
  seasonSelector: { marginBottom: 20, paddingHorizontal: 20, },
  seasonChip: { backgroundColor: COLORS.surface, paddingHorizontal: 16, paddingVertical: 8, borderRadius: 20, marginRight: 12, },
  selectedSeasonChip: { backgroundColor: COLORS.primary, },
  seasonChipText: { color: COLORS.textSecondary, fontSize: 14, fontWeight: '600', },
  selectedSeasonChipText: { color: COLORS.background, },
  languageSelector: { marginBottom: 20, paddingHorizontal: 20, },
  languageChip: { backgroundColor: COLORS.surface, paddingHorizontal: 16, paddingVertical: 8, borderRadius: 20, marginRight: 12, },
  selectedLanguageChip: { backgroundColor: COLORS.primary, },
  languageChipText: { color: COLORS.textSecondary, fontSize: 14, fontWeight: '600', },
  selectedLanguageChipText: { color: COLORS.background, },
  episodesContainer: { paddingBottom: 100, },
  episodesHeader: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', paddingHorizontal: 20, marginBottom: 16, },
  debugButton: { backgroundColor: '#FF6B6B', paddingHorizontal: 12, paddingVertical: 8, borderRadius: 6, flexDirection: 'row', alignItems: 'center', gap: 4, },
  debugButtonText: { color: COLORS.background, fontSize: 12, fontWeight: '600', },
  episodeItem: { flexDirection: 'row', paddingHorizontal: 20, paddingVertical: 12, alignItems: 'center', },
  episodeThumb: { width: 140, height: 80, borderRadius: 8, overflow: 'hidden', position: 'relative', backgroundColor: COLORS.surface, },
  episodeImage: { width: '100%', height: '100%', resizeMode: 'cover', },
  playOverlay: { position: 'absolute', top: 0, left: 0, right: 0, bottom: 0, backgroundColor: 'rgba(0,0,0,0.3)', alignItems: 'center', justifyContent: 'center', },
  episodeDuration: { position: 'absolute', bottom: 8, right: 8, backgroundColor: 'rgba(0,0,0,0.8)', paddingHorizontal: 6, paddingVertical: 2, borderRadius: 4, },
  durationText: { color: COLORS.text, fontSize: 10, fontWeight: '600', },
  episodeInfo: { flex: 1, paddingHorizontal: 16, },
  episodeTitle: { color: COLORS.text, fontSize: 16, fontWeight: '600', marginBottom: 4, },
  episodeDescription: { color: COLORS.textSecondary, fontSize: 12, lineHeight: 16, marginBottom: 4, },
  episodeDate: { color: COLORS.textMuted, fontSize: 10, },
  episodeActions: { paddingLeft: 16, },
  emptyState: { alignItems: 'center', paddingVertical: 40, },
  emptyStateText: { color: COLORS.textSecondary, fontSize: 16, fontWeight: '600', marginTop: 16, },
  emptyStateSubtext: { color: COLORS.textMuted, fontSize: 14, marginTop: 8, textAlign: 'center', },
  retryButton: { backgroundColor: COLORS.primary, paddingHorizontal: 24, paddingVertical: 12, borderRadius: 8, marginTop: 16, },
  retryButtonText: { color: COLORS.background, fontSize: 14, fontWeight: '600', },
  similarContainer: { paddingHorizontal: 20, paddingBottom: 100, },
  similarGrid: { flexDirection: 'row', flexWrap: 'wrap', gap: 16, justifyContent: 'space-between', },
  similarItem: { width: (SCREEN_WIDTH - 56) / 2, marginBottom: 16, },
  similarPoster: { width: '100%', aspectRatio: 2 / 3, borderRadius: 8, backgroundColor: COLORS.surface, marginBottom: 8, },
  similarTitle: { color: COLORS.text, fontSize: 14, fontWeight: '600', },
  detailsContainer: { paddingHorizontal: 20, paddingBottom: 100, },
  detailsGrid: { gap: 16, },
  detailItem: { backgroundColor: COLORS.surface, padding: 16, borderRadius: 8, },
  detailLabel: { color: COLORS.textMuted, fontSize: 12, fontWeight: '600', marginBottom: 4, },
  detailValue: { color: COLORS.text, fontSize: 16, },
  resolvingOverlay: { position: 'absolute', top: 0, left: 0, right: 0, bottom: 0, alignItems: 'center', justifyContent: 'center', zIndex: 20, },
  resolvingBlur: { width: '100%', height: '100%', alignItems: 'center', justifyContent: 'center', },
  resolvingContent: { backgroundColor: COLORS.surface, padding: 32, borderRadius: 16, alignItems: 'center', marginHorizontal: 40, maxWidth: 300, },
  resolvingText: { color: COLORS.text, fontSize: 14, marginTop: 16, textAlign: 'center', },
  resolvingSubtext: { color: COLORS.textSecondary, fontSize: 12, marginTop: 8, textAlign: 'center', },
  statsContainer: { backgroundColor: COLORS.surface, padding: 12, marginHorizontal: 20, marginBottom: 16, borderRadius: 8, borderLeftWidth: 4, borderLeftColor: COLORS.primary, },
  statsText: { color: COLORS.text, fontSize: 14, fontWeight: '600', },
  statsSubtext: { color: COLORS.textSecondary, fontSize: 12, marginTop: 4, },
});